-*- mode: markdown -*-

When deciding to work on a side-project three factors are needed to transition from fancy to application: goal, motivation, and time.

Time is usually the biggest sticking point for me personally but with COVID most of what I may have spent my time on this year was cancelled. However, motivation was still a huge sticking point until I came across a couple of projects that helped propel me forward. First, I spent some time ealrier this year combing over [Mary Rose Cook](https://twitter.com/maryrosecook)'s lovely [Little Lisp](https://github.com/maryrosecook/littlelisp) interpreter code. Given what I knew about Mary's previous projects it was no surprise that the Little Lisp implementation was simple and elegant. However, what I wasn't prepared for was that hacking on the interprter turned out to be straight-forward and addictive. However, it wasn't until I re-discovered [William Taysom](https://twitter.com/wtaysom)'s old Scheme-like language [Misp](https://web.archive.org/web/20090625142941/http://moonbase.rydia.net/mental/blog/programming/misp-is-a-lisp) that I had a form for the interpreter in mind. At the time of William's original blog posts about Misp I was drawn to his passion and enjoyed the implementations of the language that he posted.[^dustbin] Around the same time I found Paul Graham's original Arc tutorial [tut.txt](http://www.arclanguage.org/tut.txt) and used it extensively to guide me in what to implement next.[^readme]

<center>ToriLisp = Litle Lisp + Misp + tut.txt + Lemonad + underscore-contrib</center>

Here's a very small sample of the language:

    鳥>  (let (x 3 y 4)
           (+ (* x 2) (* y 2)))
    ;;=> 14

    (def map
      (λ (fn list)
        (if (no list)
          list
          (cons (fn (first list))
                (map fn (rest list))))))

    鳥>  (map (+ 10) '(1 2 3))
    ;;=> [ 11, 12, 13 ]

    鳥>  ({x y | (/ (+ x y) 2)} 2 4)
    ;;=> 3

    鳥>  (len "abc")
    ;;=> 3
    鳥>  (len {a | a})
    ;;=> 1
    鳥>  (len +)
    ;;=> 2

If I wanted to present a list of features then the following list would	work:

 - Functional
 - Immutable access to JavaScript arrays and hash-maps.
 - function auto-currying
 -

[^dustbin]: Though the implementations did not make the Internet Archive it seems. I reached out to Mr. Taysom years ago and he was kind enough to send me the code but I hesitate to share them publically without
his approval.

[^readme]: Consider this a form of [README-driven language development](https://tom.preston-werner.com/2010/08/23/readme-driven-development.html).

