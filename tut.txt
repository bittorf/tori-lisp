[This is a brief tutorial on Tori-Lisp, an ersatz Lisp for little
birds. A passing familiarity with Lisp and Lisp-like languages is
presumed.]

TL programs consist of expressions. The simplest expressions are
things like numbers and strings, which evaluate to themselves.

    鳥>  25
    ;;=> 25

    鳥>  "foo"
    ;;=> 'foo'

There's an important detail about TL that bears mentioning at this
time. That is, the language is hosted on the JavaScript programming
language and thus "bottoms-out" at JavaScript data-types and
structures. Therefore, the TL console will always display its
results as JavaScript types and indeed, the evaluation engine of
the language operates on and with JavaScript types and functions.

TL is like most Lisp-like languages in that the list form
represents a function call:

    鳥>  (+ 1 2)
    ;;=> 3

Since expression and evaluation are both defined recursively, 
programs can be as complex as you want:

    鳥>  (+ (+ 1 2) (+ 3 (+ 4 5)))
    ;;=> 15 

Unlike many Lisps, TL functions always expect a fixed number of 
arguments. For example, the `+` function shown above expects to
receive 2 arguments and if it receives too many then and error
occurs:

    鳥>  (+ 1 2 3)
    ;;=> Error: Too many arguments to function: expected 2, got 3

However, if you supply fewer arguments than a function expects then
a new function will be reurned:

    鳥>  (+ 1)
    ;;=> [Function: curried]

Functions in TL are "curried" by default. This means that when a 
function is called it might return another function that expects to 
receive the remainder of its expected arguments. Once all of the 
expected arguments are recieved the function is executed and a 
result returned.

    鳥>  ((+ 1) 2)
    ;;=> 3

Lisp dialects like TL have a data type most languages don't:
symbols.  We've already seen one: `+` is a symbol.  Symbols don't
evaluate to themselves the way numbers and strings do.  They return
whatever value they've been assigned.

If we give foo the value 13, it will return 13 when evaluated:

    鳥>  (def foo 13)
	;;=> 13
    鳥>  foo
	;;=> 13

You can turn off evaluation by putting a single quote character
before an expression.  So `'foo` returns the JavaScript equivalent
to a TL symbol `"'foo"`.

    鳥>  'foo
	;;=> "'foo"

Particularly observant readers may be wondering how we got away
with using `foo` as the first argument to `def`.  If the arguments 
are evaluated left to right, why didn't this cause an error when 
`foo` was evaluated?  There are some operators that violate the usual
evaluation rule, and `def` is one of them.  Its first argument isn't
evaluated.

    鳥>  (+ 1 2)
	;;=> 3
    鳥>  '(+ 1 2)
	;;=> ["'+", 1, 2]

The first expression returns the number 3.  The second, because it
was quoted, returns a JS array consisting of the string `"'+` and the 
numbers 1 and 2. The use of the pattern `"'symbol"` is the way that
symbols are encoded in TL.

You can build up TL lists with `cons`, which returns a list with a new
element on the front:

    鳥>  (cons 'f '(a b))
	;;=> [ "'f", "'a", "'b" ]

It doesn't change the original list:

    鳥> (def x '(a b))
    ;=> [ "'a", "'b" ]
	
    鳥> (cons 'f x)
    ;;=> [ "'f", "'a", "'b" ]
	
    鳥> x
    ;=> [ "'a", "'b" ]

The empty list is represented by the symbol `nil`, which is defined
to evaluate to itself.  So to make a list of one element you say:

    鳥> (cons 'a nil)
	;;=> [ "'a" ]

You can take lists apart with car and cdr, which return the first
element and everything but the first element respectively:

    鳥>  (first '(a b c))
	;;=> "'a"
	
    鳥>  (rest '(a b c))
	;;=> ["'b", "'c"]

Additionally, TL provides a `head` function to take apart a list by 
returning a list of the first element:

    鳥>  (head '(a b c))
    ;;=> [ "'a" ]

We've already seen some functions: `+`, `cons`, `first`, `rest`, and `head`.  
You can define new ones with def, which takes a symbol to use as the name, a 
list of symbols representing the parameters, and then zero or more expressions 
called the body.  When the function is called, those expressions will be 
evaluated in order with the symbols in the body temporarily set ("bound") to 
the corresponding argument. Whatever the last expression returns will be 
returned as the value of the call.

Here's a function that takes two numbers and returns their average:

    鳥>  (def average {x y | (/ (+ x y) 2)})
    ;;=> [Function: curried]
    鳥>  (average 2 4)
    ;;=> 3

From the definition above you'll notice that TL uses a literal syntax for
functions of the form `{args | body}`. This is sugar for the more conventional
`(λ (x y) (/ (+ x y) 2))` form. In either case, the body of the function consists 
of one expression, (/ (+ x y) 2). It's common for functions to consist of one 
expression; in purely functional code (code with no side-effects) they always do.

What's the strange-looking object returned as the value of the `def`
expression?  That's what a function looks like.  In TL, as in most
Lisps, functions are a data type, just like numbers or strings.

Indeed, user-defined functions can be inspected at runtime:

	鳥>  (meta/body average)
	;;=> [ [ "'/", [ "'+", "'x", "'y" ], 2 ] ]
	
	鳥>  (meta/params average)
	;;=> [ "'x", "'y" ]

This capability will come in handy later in the tutorial but for now we can
proceed.

Of course you can use a literal function wherever you could use
a symbol whose value is one, e.g.

    鳥>  ({x y | (/ (+ x y) 2)} 2 4)
    ;;=> 3

This expression has three elements, `{x y | (/ (+ x y) 2)}`, which
yields a function that returns averages, and the numbers 2 and 4.
So when you evaluate all three expressions and pass the values of
the second and third to the value of the first, you pass 2 and 4
to a function that returns averages, and the result is 3.

There's one thing you can't do with functions that you can do with
data types like symbols and strings: you can't print them out in a
way that could be read back in.  The reason is that the function 
could be a closure; displaying closures is a tricky problem.

In TL, data structures can be used wherever functions are, and
they behave as functions from indices to whatever's stored there.
So to get the first element of a string you say:

    鳥>  ("foo" 0)
    ;;=> 'f'

Or to get a slice of the string you can use:

    鳥>  ("foo" 0 2)
    ;;=> 'fo'

There is one commonly used operator for establishing temporary
variables, namely `let`.

    鳥>  (let (x 1) 
           (+ x (* x 2)))
    ;;=> 3

To bind multiple variables, just add more pairs to the `let`.

    鳥>  (let (x 3 y 4)
           (+ (* x 2) (* y 2)))
    ;;=> 14

So far we've only had things printed out implicity as a result of
evaluating them.  The standard way to print things out in the middle
of evaluation is with `out`. It takes multiple arguments, the first 
being the "port" to print to and the rest that print in order.

Here's a variant of average that tells us what its arguments were:

    鳥> (def average 
	      {x y | (do (out <c> "my args were: " x " and " y crlf) 
		             (/ (+ x y) 2))})
    ;;=> [Function: curried]
	
    鳥>  (average 100 200)
    my args were: 100 and 200
    ;;=> 150

A couple of points to note about the call to `out` is that the first 
argument is the "port" that the rest of the arguments are written to.
In the case of the call above, the argument `<c>` means that the
print happens to the console (i.e. stdout). Also, the argument `crlf`
indicates that a newline should be printed.



    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
    鳥> 
	
